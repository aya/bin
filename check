#!/bin/bash
#
# # test script for linux server
 #
# Author: Yann Autissier <yann.autissier@anotherservice.com>
#
# History:
# 20131203 AYA : specific formated output for account_lists
# 20131021 AYA : iostat implementation, PATH variable for crontab calls
# 20130923 AYA : tests can be called with syntax like function_name_operand or function_name://operand
# 20130917 AYA : tcp, ssl, http, https connections
# 20130910 AYA : bash v2 compatibility
# 20130826 AYA : wget profiles and functions from remote files
# 20130824 AYA : pass arguments to tests, call restart on failed tests, factorize functions
# 20130823 AYA : get profile from hostname, summary output for supervision, debian support
# 20130821 AYA : user account list
# 20130819 AYA : package information
# 20130816 AYA : define group of tests in profiles
# 20130814 AYA : check open files for DB2, numeric output for supervision
# 20130731 AYA : first version for redhat, check few services
#
# TODO: smtp, smtps, pop3, pop3s, imap, imaps, smtp with antivirus, smtp auth
#
RELEASE="0.9.6"
PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"

# #
 #
# error codes
exit=0
ERROR_NOT_FOUND_ALL_BINARIES=1
ERROR_NOT_FOUND_TEST=2
ERROR_NOT_FOUND_PROCESS=3
ERROR_NOT_FOUND_SERVICE=4
ERROR_NOT_FOUND_PACKAGE=5
ERROR_NOT_FOUND_PATTERN=6
ERROR_CONNECTION_FAILED=8
ERROR_RESPONSE_CODE=9
ERROR_UPGRADE_FAILED=127
ERROR_UNDEFINED=128
ERROR_LOCKED=255

VALID_RESPONSE_CODE_HTTP="200 301 302"
VALID_RESPONSE_CODE_SMTP="200"

# need bash >= 3
# [ ${BASH_VERSION:0:1} -ge 3 ] || exit 255

# error code goes through pipes (need bash >= 3)
[ ${BASH_VERSION:0:1} -ge 3 ] && set -o pipefail

# #
 #
# binaries
AWK=$(which awk 2>/dev/null)
CAT=$(which cat 2>/dev/null)
CUT=$(which cut 2>/dev/null)
DPKG=$(which dpkg 2>/dev/null)
HOSTNAME=$(which hostname 2>/dev/null)
GREP=$(which grep 2>/dev/null)
LAST=$(which last 2>/dev/null)
LASTLOG=$(which lastlog 2>/dev/null)
LSOF=$(which lsof 2>/dev/null)
PIDOF=$(which pidof 2>/dev/null)
PS=$(which ps 2>/dev/null)
RPM=$(which rpm 2>/dev/null)

# #
 #
# default profile
DEFAULT=""
# this script (remote upgrade)
REMOTE_SCRIPT="http://10.100.11.80/tools/check"

# date format
DATE_FORMAT="%d/%m/%Y"

# #
 #
# help
function usage() {
echo "Usage: $0 [options] test [test [...]]
Test de serveurs linux - v${RELEASE}

options:
        -a, --all               lance tous les tests
        -d, --debug             active la mode de deboggage
        -h, --help              affiche ce message
        -i, --info              affiche des informations detaillees pour certains tests
        -l, --list              affiche les jeux de tests de tous les profils
        -la, --list --all       affiche tous les jeux de tests disponibles
        -n, --numeric           retourne uniquement des valeurs numeriques
        -o, --operand=<operand> passe un argument <operand> a tous les tests
        -p, --profile=<profil>  utilise le jeu de test pour le <profil>
        -q, --quiet             active le mode silencieux
        -r, --remote            affiche des retours chariot pour un appel du script a distance
        -s, --summary           affiche la liste des tests en erreur
        -t, --table             affiche les listes dans un format compatible avec les tableurs
        -u, --update            force la mise a jour des fichiers de profiles et de fonctions
        -v, --version           affiche la version"
}

# #
 #
# check options
while getopts "adhilno:p:qrstuv-:" Option; do
    case "$Option" in
        -)
            case $OPTARG in
                all)
                    ALL=1
                    ;;
                debug)
                    DEBUG=1
                    ;;
                help)
                    HELP=1
                    ;;
                info)
                    INFO=1
                    ;;
                list)
                    LIST=1
                    ;;
                numeric)
                    NUMERIC=1
                    ;;
                operand)
                    OPERAND="${OPERAND} ${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                    ;;
                operand=*)
                    OPERAND="${OPERAND} ${OPTARG#*=}"
                    ;;
                profile)
                    PROFILE="${PROFILE} PROFILE_${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                    ;;
                profile=*)
                    PROFILE="${PROFILE} PROFILE_${OPTARG#*=}"
                    ;;
                quiet)
                    QUIET=1
                    ;;
                remote)
                    REMOTE=1
                    ;;
                summary)
                    SUMMARY=1
                    ;;
                table)
                    TABLE=1
                    ;;
                update)
                    UPDATE=$((${UPDATE:-0} + 1))
                    ;;
                version)
                    VERSION=1
                    ;;
            esac
            ;;
        a)
            ALL=1
            ;;
        d)
            DEBUG=1
            ;;
        h)
            HELP=1
            ;;
        i)
            INFO=1
            ;;
        l)
            LIST=1
            ;;
        n)
            NUMERIC=1
            ;;
        o)
            OPERAND="${OPERAND} ${OPTARG}"
            ;;
        p)
            PROFILE="${PROFILE} PROFILE_${OPTARG}"
            ;;
        q)
            QUIET=1
            ;;
        r)
            REMOTE=1
            ;;
        s)
            SUMMARY=1
            ;;
        t)
            TABLE=1
            ;;
        u)
            UPDATE=$((${UPDATE:-0} + 1))
            ;;
        v)
            VERSION=1
            ;;
        *)
            usage
            exit 0
            ;;
    esac
done
shift $(($OPTIND - 1))

# #
 #
# check binaries
[ -z "${AWK}" ] || [ -z "${CAT}" ] || [ -z "${CUT}" ] || [ -z "${HOSTNAME}" ] || [ -z "${GREP}" ] || [ -z "${LAST}" ] ||[ -z "${LASTLOG}" ] ||  [ -z "${LSOF}" ] || [ -z "${PIDOF}" ] || [ -z "${PS}" ] || [ -z "${RPM}" -a -z "${DPKG}" ] && exit=${ERROR_NOT_FOUND_ALL_BINARIES}
[ ${exit} -ne 0 ] && echo "ERROR: Unable to find all needed binaries" >&2 && exit $exit

# #
 #
# process options
# set debug
[ ${DEBUG} ] && set -x
# show help
[ ${HELP} ] && usage && exit 0
# show version
[ ${VERSION} ] && echo "$(basename $0) v${RELEASE}" && exit 0

# wget version
WGET_OPTION="-T 3 --proxy=off -q"

# update profiles and functions from remote host
[ ${UPDATE:-0} -ge 1 ] && {
    # get profiles from remote file
    wget ${WGET_OPTION} "${REMOTE_SCRIPT}_profile" -O "/tmp/.$(basename $0)_profile.$$" 2>/dev/null || echo "WARNING: Unable to wget ${REMOTE_SCRIPT}_profile" >&2
    # if file is not empty, overwrite local file
    [ -s "/tmp/.$(basename $0)_profile.$$" ] && mv "/tmp/.$(basename $0)_profile.$$" $0_profile && chmod +r $0_profile || error=${ERROR_UPGRADE_FAILED}
    # get functions from remote file
    wget ${WGET_OPTION} "${REMOTE_SCRIPT}_function" -O "/tmp/.$(basename $0)_function.$$" 2>/dev/null || echo "WARNING: Unable to wget ${REMOTE_SCRIPT}_function" >&2
    # if file is not empty, overwrite local file
    [ -s "/tmp/.$(basename $0)_function.$$" ] && mv "/tmp/.$(basename $0)_function.$$" $0_function && chmod +r $0_function || error=${ERROR_UPGRADE_FAILED}
    # exit if upgrade failed
    [ ${error:-0} -ne 0 ] && echo "ERROR: Upgrade failed !" >&2 && exit ${error} || [ ${QUIET} ] || echo "INFO: Upgrade successful"
}

# Not documented : auto upgrade, overwrite this script !
[ ${UPDATE:-0} -gt 1 ] && {
    [ ! ${QUIET} ] && echo -n "Do you really want to upgrade this script ? [y/N] : " && read UPGRADE
    [ ${QUIET:-0} -ne 0 -o "${UPGRADE:0:1}" = "Y" -o "${UPGRADE:0:1}" = "y" ] && {
        wget ${WGET_OPTION} "${REMOTE_SCRIPT}" -O "/tmp/.$(basename $0).$$" 2>/dev/null || error=${ERROR_UPGRADE_FAILED}
        [ ${error:-0} -ne 0 ] && echo "WARNING: Unable to wget ${REMOTE_SCRIPT}" >&2 && exit ${error:-0}
        [ ! ${QUIET} ] && NEW_RELEASE=$(awk 'BEGIN {FS="="} $1 == "RELEASE" {print $2}' /tmp/.$(basename $0).$$ |sed 's/"//g') && echo -n "Downloaded version : ${NEW_RELEASE}, Current version : ${RELEASE}, continue ? [y/N] : " && read UPGRADE_SCRIPT
        [ ${QUIET:-0} -ne 0 -o "${UPGRADE_SCRIPT:0:1}" = "Y" -o "${UPGRADE_SCRIPT:0:1}" = "y" ] && {
            [ -s "/tmp/.$(basename $0).$$" ] && mv "/tmp/.$(basename $0).$$" $0 && chmod +x $0 || error=${ERROR_UPGRADE_FAILED}
            [ ${error:-0} -ne 0 ] && echo "ERROR: Auto upgrade failed !" >&2 || [ ${QUIET} ] || echo "INFO: Auto upgrade successful"
        }
    }
# exit
exit ${error:-0}
}

# load profiles override
[ -r "$0_profile" ] && source "$0_profile"
# functions override is loaded after local functions definition

# list profiles
[ ${LIST} ] && [ ! ${ALL} ] && \
    echo "Listing profiles :" && \
    echo DEFAULT: ${DEFAULT} && \
    for profile in $(compgen -v PROFILE_); do
       echo ${profile/PROFILE_/}: ${!profile}
    done && exit 0
# output numeric values for nagios
[ ${NUMERIC} ] && OK=1 || OK="OK"
[ ${NUMERIC} ] && ERROR=0 || ERROR="ERROR"
# -s flag display only summary
[ ${SUMMARY} ] && exec 3>&1 >/dev/null

# #
 #
# get list of tests from argv
TESTS="$@"
# if no input, check hostname to define current profile
hostname="$(hostname -s 2>/dev/null)"
# ^^ need bash v4
# HOSTNAME=${hostname^^}
HOSTNAME=$(hostname -s 2>/dev/null |tr '[a-z]' '[A-Z]')
[ -z "${TESTS}" ] && for profile in $(compgen -v PROFILE_); do
    # if we found a PROFILE_ variable that looks like the hostname
    case "${HOSTNAME/-/}" in
        *${profile/PROFILE_/}*)
            PROFILE="${PROFILE} ${profile}"
    esac
done
# if no input, use DEFAULT tests
[ -n "${TESTS}" ] || TESTS="${DEFAULT}"
# then add tests from profiles
for profile in ${PROFILE}; do
    # check if profile is defined
    [ -n "${!profile}" ] && TESTS="${TESTS} ${!profile}" || [ ${QUIET} ] || echo "WARNING: ${profile} is not a valid profile" >&2
done

# #
 #
# functions are defined from here
TABLE_FIELD_PREFIX="\"hostname\";"
TABLE_PREFIX="\"${HOSTNAME}\";"
TABLE_FIELD_ACCOUNT="account"
TABLE_FIELD_LASTLOG="lastlog"

# active accounts
function check_account_active() {
    account_active="$(grep -vE '.*:\*|:\!' /etc/shadow 2>/dev/null |awk -F: '{print $1}')"
    [ ${NUMERIC} ] && account_active="$(for account_active_user in ${account_active}; do id -u ${account_active_user}; done)"
    [ ${TABLE} ] && account_active="${TABLE_FIELD_PREFIX}\"${TABLE_FIELD_ACCOUNT}\";\n$(for account_active_table in ${account_active}; do echo ${TABLE_PREFIX}\"${account_active_table}\"\;\\n; done)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo -e ${account_active}
    return ${error:-0}
}

# account lastlog
function check_account_lastlog() {
    [ ${QUIET} ] || echo
    LANG=en_EN lastlog 2>/dev/null |awk '$2 ~ /(pts|tty)/' | (\
        # on prepare les entetes du tableau
        [ ${TABLE} ] && { 
            account_lastlog="${TABLE_FIELD_PREFIX}\"${TABLE_FIELD_ACCOUNT}\";\"${TABLE_FIELD_LASTLOG}\";"
            [ ${REMOTE} ] && account_lastlog="${account_lastlog}"'\\n' || account_lastlog="${account_lastlog}\n"
        }
        # on prepare les lignes du tableau
        while read account_lastlog_user account_lastlog_pts account_lastlog_address account_lastlog_date; do 
            [ -z "${account_lastlog_user}" ] && continue
            account_lastlog_line="${account_lastlog_user}: $(date -d "${account_lastlog_date}" +${DATE_FORMAT} 2>/dev/null)"
            [ ${NUMERIC} ] && account_lastlog_line="$(id -u ${account_lastlog_user}): $(date -d "${account_lastlog_date}" +%s 2>/dev/null)"
            [ ${TABLE} ] && account_lastlog_line="${TABLE_PREFIX}\"$(echo ${account_lastlog_line}| sed 's/: /\";\"/')\";" 
            [ ${REMOTE} ] && account_lastlog="${account_lastlog}${account_lastlog_line}"'\\n' || account_lastlog="${account_lastlog}${account_lastlog_line}\n"
            account_lastlog_user=""; account_lastlog_pts=""; account_lastlog_address=""; account_lastlog_date=""
        done
    echo -e ${account_lastlog}
    )
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# account last logged in users
function check_account_login() {
    [ ${QUIET} ] || echo
    LANG=en_EN last 2>/dev/null |awk '$2 ~ /(pts|tty)/' |\
        while read account_login_user account_login_pts account_login_address account_login_date; do 
            [ -z "${account_login_user}" ] || [ "${account_login_user}" = "reboot" ] && continue
            account_login_date="$(echo ${account_login_date} |awk '{print $1" "$2" "$3" "$4}')"
            [ ${NUMERIC} ] && echo -n "$(id -u ${account_login_user}): " || echo -n "${account_login_user}: "
            [ ${NUMERIC} ] && echo -n $(date -d "${account_login_date}" +%s 2>/dev/null) || echo -n $(date -d "${account_login_date}" +${DATE_FORMAT} 2>/dev/null)
            [ ${QUIET} ] && echo -n '\\n' || echo
            account_login_user=""; account_login_pts=""; account_login_address=""; account_login_date=""
        done
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    [ ${QUIET} ] && echo
    return ${error:-0}
}

# account list
function check_account_list() {
    account_list="$(cat /etc/passwd 2>/dev/null |grep -vE '^(#|$)' |cut -d: -f1)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    # echo ${account_list}
    # [ ${NUMERIC} ] || [ ${QUIET} ] || cat /etc/passwd 2>/dev/null |grep -vE '^(#|$)' |\
    cat /etc/passwd 2>/dev/null |grep -vE '^(#|$)' |\
        while IFS=":" read account_list_user account_list_password account_list_uid account_list_gid account_list_description account_list_homedir account_list_loginshell; do
            [ -z "${account_list_user}" ] && continue
            # check login shell
            # only bash v3
            # [[ "${account_list_loginshell}" =~ /(usr/)?s?bin/(nologin|false) ]] && account_list_login_status='nologin' || account_list_login_status='enabled'
            case "${account_list_loginshell}" in
                /sbin/nologin|/sbin/false)
                    account_list_login_status='nologin'
                ;;
                /bin/*sh|/usr/bin/*sh)
                    account_list_login_status='enabled'
                ;;
                *)
                    account_list_login_status='unknown'
                ;;
            esac
            # check password
            account_list_shadow=$(cat /etc/shadow 2>/dev/null |grep -vE '^(#|$)' |awk 'BEGIN {FS=":"} $1 == "'${account_list_user}'" {print $2}')
            [ "${account_list_password}" = 'x' ] && account_password="${account_list_shadow}" || account_password="${account_list_password}"
            # check password algorithm
            echo "${account_password}" |grep -E '^\$(1|md5)\$' >/dev/null 2>&1 && account_list_password_type='md5'
            echo "${account_password}" |grep -E '^\$(2|2a|2x|2y)\$' >/dev/null 2>&1 && account_list_password_type='blowfish'
            echo "${account_password}" |grep -E '^\$(3)\$' >/dev/null 2>&1 && account_list_password_type='nt-hash'
            echo "${account_password}" |grep -E '^\$(4)\$' >/dev/null 2>&1 && account_list_password_type='sha1'
            echo "${account_password}" |grep -E '^\$(5)\$' >/dev/null 2>&1 && account_list_password_type='sha2-256'
            echo "${account_password}" |grep -E '^\$(6)\$' >/dev/null 2>&1 && account_list_password_type='sha2-512'
            # check password status
            [[ "${account_password}" = '*' || "${account_password}" = '!' ]] && account_list_password_type='locked'
            [[ "${account_password}" = '!!' ]] && account_list_password_type='expired'
            [ "${account_password}" = '' ] && account_list_password_status='empty'
            # check last login
            account_list_last_login="$(LANG=en_EN lastlog -u ${account_list_user} 2>/dev/null |sed 1d |awk '$2 ~ /pts/ {$1=$2=$3=""; print}; $2 ~ /tty/ {$1=$2=""; print}')"
            [ -n "${account_list_last_login}" ] && account_list_last_login=$(date -d "${account_list_last_login}" +${DATE_FORMAT} 2>/dev/null) || account_list_last_login="never"
            # check if account is in use
            ls /var/spool/cron 2>/dev/null |grep ${account_list_user} >/dev/null && account_list_service="crontab" 
            ls /var/spool/cron/* 2>/dev/null |grep ${account_list_user} >/dev/null && account_list_service="crontab" 
            ps aux 2>/dev/null |awk '$7 == "?" {print $1}' |grep ${account_list_user} >/dev/null && account_list_service="${account_list_service} process"
            [ -n "${account_list_service}" ] && account_list_service="$(echo ${account_list_service})" || account_list_service="none"
            # print results and accounts without password in RED
            [ "${account_list_login_status}" = "enabled" ] && [ "${account_list_password_type}" = "empty" ] && echo -ne "\e[01;31m"
            echo -n "user: ${account_list_user}, "
            echo -n "uid: ${account_list_uid}, "
            echo -n "gid: ${account_list_gid}, "
            echo -n "shell: ${account_list_loginshell}, "
            # echo -n "description: \"${account_list_description//\"/}\", "
            echo -n "status: ${account_list_login_status}, "
            echo -n "password: ${account_list_password_type}, "
            echo -n "last_login: ${account_list_last_login}, "
            echo -n "service: ${account_list_service}"
            # end of line for:  print results and accounts without password in RED
            [ "${account_list_login_status}" = "enabled" ] && [ "${account_list_password_type}" = "empty" ] && echo -ne "\e[0m"
            [ ${QUIET} ] && echo -n '\\n' || echo
            account_list_user=""; account_list_password=""; account_list_uid=""; account_list_gid=""; account_list_description=""; account_list_homedir=""; account_list_loginshell=""
            account_list_login_status=""; account_list_password_type="unknown"; account_list_shadow=""; account_list_last_login=""; account_list_service=""
        done
    [ ${QUIET} ] && echo
    return ${error:-0}
}

# account logged in
function check_account_logged_in() {
    account_logged_in="$(ps aux |awk '$7 ~ /pts|tty/ {print $1}' 2>/dev/null |sort -u)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo ${account_logged_in}
    return ${error:-0}
}

# account with crontab
function check_account_with_crontab() {
    [ ${NUMERIC} ] && account_with_crontab="$(ls -ln /var/spool/cron /var/spool/cron/* 2>/dev/null |awk '$1 ~ /^-/ {print $3}')" || account_with_crontab="$(ls -l /var/spool/cron /var/spool/cron/* 2>/dev/null |awk '$1 ~ /^-/ {print $3}' |sort -u)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo ${account_with_crontab}
    [ ${INFO} ] && for account_with_crontab_user in ${account_with_crontab}; do 
        cat /var/spool/cron/${account_with_crontab_user} /var/spool/cron/*/${account_with_crontab_user} 2>/dev/null |awk '$0 !~ /^(#|$)/ {print "'${account_with_crontab_user}': "$0}'
    done
    return ${error:-0}
}

# account with privileges
function check_account_with_privilege() {
    account_with_privilege="$(echo $(cat /etc/passwd 2>/dev/null |awk 'BEGIN {FS=":"} $3 == "0" {print $1}') $(check_account_with_sudo) |xargs -n1 |awk '!t[$0]++' |xargs)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo ${account_with_privilege}
    [ ${INFO} ] && for account_with_privilege_user in ${account_with_privilege}; do 
        echo ${account_with_privilege_user}
    done
    return ${error:-0}
}

# account with process
function check_account_with_process() {
    [ ${NUMERIC} ] && account_with_process="$(ps aunx 2>/dev/null |awk '$7 == "?" {print $1}' |sort -u)" || account_process="$(ps aux 2>/dev/null |awk '$7 == "?" {print $1}' |sort -u)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo ${account_with_process}
    return ${error:-0}
}

# account with sudo privileges
function check_account_with_sudo() {
    # user or group with sudo (root    ALL=(ALL)       ALL)
    account_or_group_with_sudo="$(cat /etc/sudoers /etc/sudoers.d/* 2>/dev/null |awk '$0 !~ /^(#|$)/ && $2 ~ /=/ && $3 ~ /ALL/ {print $1}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    for account_or_group in ${account_or_group_with_sudo}; do 
        # getent will fail if group does not exist
        [ ${BASH_VERSION:0:1} -ge 3 ] && set +o pipefail
        # group begins with %
        [ ${account_or_group:0:1} = "%" ] && account_with_sudo="${account_with_sudo} $(getent group ${account_or_group/\%/} |awk 'BEGIN {FS=":"} {print $4}' |sed 's/,/ /g')" || account_with_sudo="${account_with_sudo} ${account_or_group}"
        [ ${BASH_VERSION:0:1} -ge 3 ] && set -o pipefail
    done
    echo ${account_with_sudo} |xargs -n1 |awk '!t[$0]++' |xargs
    return ${error:-0}
}

# active accounts
function check_account_without_password() {
    account_without_password="$(cat /etc/passwd /etc/shadow 2>/dev/null |grep -vE '^(#|$)' |awk 'BEGIN {FS=":"} $2 == "" {print $1}' |sort -u)"
    [ ${NUMERIC} ] && account_without_password="$(for account_without_password_user in ${account_without_password}; do id -u ${account_without_password_user}; done)"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo ${account_without_password}
    return ${error:-0}
}

# disk I/O statistics
function check_disk_stat() {
    # from http://exchange.nagios.org/directory/Plugins/System-Metrics/Storage-Subsystem/check_diskstat/details
    for disk in $@; do
        DISK=${disk}
        WARNING="300,10000,10000"
        CRITICAL="400,20000,20000"

        E_OK=0
        E_WARNING=1
        E_CRITICAL=2
        E_UNKNOWN=3

        # generate HISTFILE filename
        HISTFILE=/var/tmp/check_diskstat.$DISK

        # process thresholds
        WARN_TPS=$(echo $WARNING | cut -d , -f 1)
        WARN_READ=$(echo $WARNING | cut -d , -f 2)
        WARN_WRITE=$(echo $WARNING | cut -d , -f 3)
        CRIT_TPS=$(echo $CRITICAL | cut -d , -f 1)
        CRIT_READ=$(echo $CRITICAL | cut -d , -f 2)
        CRIT_WRITE=$(echo $CRITICAL | cut -d , -f 3)

        if [ -z "$WARN_TPS" -o -z "$WARN_READ" -o -z "$WARN_WRITE" ]; then
            echo "Need 3 values for warning threshold (tps,read,write)"
            return $E_UNKNOWN
        fi
        if [ -z "$CRIT_TPS" -o -z "$CRIT_READ" -o -z "$CRIT_WRITE" ]; then
            echo "Need 3 values for critical threshold (tps,read,write)"
            return $E_UNKNOWN
        fi
                
        if [ ! -f "/sys/block/$DISK/stat" ]; then
            return $E_UNKNOWN
        fi

        NEWDISKSTAT=$(cat /sys/block/$DISK/stat)


        if [ ! -f $HISTFILE ]; then
            echo $NEWDISKSTAT >$HISTFILE
            return $E_UNKNOWN
        fi

        [ -f $HISTFILE ] || return $E_UNKNOWN

        OLDDISKSTAT=$(cat $HISTFILE)

        if [ $? -ne 0 ]; then
            return $E_UNKNOWN
        fi

        OLDDISKSTAT_TIME=$(stat $HISTFILE | grep Modify | sed 's/^.*: \(.*\)$/\1/')
        OLDDISKSTAT_EPOCH=$(date -d "$OLDDISKSTAT_TIME" +%s)
        NEWDISKSTAT_EPOCH=$(date +%s)

        echo $NEWDISKSTAT >$HISTFILE
        # now we have old and current stat; 
        # let compare it
        OLD_SECTORS_READ=$(echo $OLDDISKSTAT | awk '{print $3}')
        NEW_SECTORS_READ=$(echo $NEWDISKSTAT | awk '{print $3}')
        OLD_READ=$(echo $OLDDISKSTAT | awk '{print $1}')
        NEW_READ=$(echo $NEWDISKSTAT | awk '{print $1}')
        OLD_WRITE=$(echo $OLDDISKSTAT | awk '{print $5}')
        NEW_WRITE=$(echo $NEWDISKSTAT | awk '{print $5}')

        OLD_SECTORS_WRITTEN=$(echo $OLDDISKSTAT | awk '{print $7}')
        NEW_SECTORS_WRITTEN=$(echo $NEWDISKSTAT | awk '{print $7}')

        # kernel handles sectors by 512bytes
        # http://www.mjmwired.net/kernel/Documentation/block/stat.txt
        SECTORBYTESIZE=512

        let "SECTORS_READ = $NEW_SECTORS_READ - $OLD_SECTORS_READ"
        let "SECTORS_WRITE = $NEW_SECTORS_WRITTEN - $OLD_SECTORS_WRITTEN"
        let "TIME = $NEWDISKSTAT_EPOCH - $OLDDISKSTAT_EPOCH"
        [ $TIME -lt 1 ] && let "TIME = 1"
        let "BYTES_READ_PER_SEC = $SECTORS_READ * $SECTORBYTESIZE / $TIME"
        let "BYTES_WRITTEN_PER_SEC = $SECTORS_WRITE * $SECTORBYTESIZE / $TIME"
        let "TPS=($NEW_READ - $OLD_READ + $NEW_WRITE - $OLD_WRITE) / $TIME"
        let "KBYTES_READ_PER_SEC = $BYTES_READ_PER_SEC / 1024"
        let "KBYTES_WRITTEN_PER_SEC = $BYTES_WRITTEN_PER_SEC / 1024"

        EXITCODE=$E_OK

        # check TPS
        if [ $TPS -gt $WARN_TPS ]; then
            if [ $TPS -gt $CRIT_TPS ]; then
                EXITCODE=$E_CRITICAL
            else
                EXITCODE=$E_WARNING
            fi
        fi

        # check read
        if [ $BYTES_READ_PER_SEC -gt $WARN_READ ]; then
            if [ $BYTES_READ_PER_SEC -gt $CRIT_READ ]; then
                EXITCODE=$E_CRITICAL
            else
                [ "$EXITCODE" -lt $E_CRITICAL ] && EXITCODE=$E_WARNING
            fi
        fi

        # check write
        if [ $BYTES_WRITTEN_PER_SEC -gt $WARN_WRITE ]; then
            if [ $BYTES_WRITTEN_PER_SEC -gt $CRIT_WRITE ]; then
                EXITCODE=$E_CRITICAL
            else
                [ "$EXITCODE" -lt $E_CRITICAL ] && EXITCODE=$E_WARNING
            fi
        fi

        if [ "${DISK_TPS}" ]; then
            [ "${QUIET}" -o "${NUMERIC}" ] && echo "${TPS}" || echo "$TPS io/s"
        elif [ "${DISK_READ}" ]; then
            [ "${QUIET}" -o "${NUMERIC}" ] && echo "${BYTES_READ_PER_SEC}" || echo "${BYTES_READ_PER_SEC} b/s"
        elif [ "${DISK_WRITE}" ]; then
            [ "${QUIET}" -o "${NUMERIC}" ] && echo "${BYTES_WRITTEN_PER_SEC}" || echo "${BYTES_WRITTEN_PER_SEC} b/s"
        else
            [ "${QUIET}" -o "${NUMERIC}" ] && echo "${TPS} ${BYTES_READ_PER_SEC} ${BYTES_WRITTEN_PER_SEC}" || echo "$TPS io/s, read ${BYTES_READ_PER_SEC} b/s,  write ${BYTES_WRITTEN_PER_SEC} b/s"
        fi
        operand_error=$EXITCODE && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
    done
    # [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# disk I/O statistics
function check_disk_io() {
    [ "${QUIET}" ] || echo
    devs="${OPERAND} $@" && [ -z "${devs/ /}" ] && devs="$(ls /sys/block)"
    for dev in ${devs}; do
        if [ -L /sys/block/$dev/device ]; then
            [ "${QUIET}" ] || echo -n "${dev}: "
            DISK_TPS=1 check_disk_stat ${dev}
            operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        fi
    done
    # [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# disk read statistics
function check_disk_read() {
    [ "${QUIET}" ] || echo
    devs="${OPERAND} $@" && [ -z "${devs/ /}" ] && devs="$(ls /sys/block)"
    for dev in ${devs}; do
        if [ -L /sys/block/$dev/device ]; then
            [ "${QUIET}" ] || echo -n "${dev}: "
            DISK_READ=1 check_disk_stat ${dev}
            operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        fi
    done
    # [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# disk write statistics
function check_disk_write() {
    [ "${QUIET}" ] || echo
    devs="${OPERAND} $@" && [ -z "${devs/ /}" ] && devs="$(ls /sys/block)"
    for dev in ${devs}; do
        if [ -L /sys/block/$dev/device ]; then
            [ "${QUIET}" ] || echo -n "${dev}: "
            DISK_WRITE=1 check_disk_stat ${dev}
            operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        fi
    done
    # [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# disk statistics
function check_disk_stats() {
    [ "${QUIET}" ] || echo
    devs="${OPERAND} $@" && [ -z "${devs/ /}" ] && devs="$(ls /sys/block)"
    for dev in ${devs}; do
        if [ -L /sys/block/$dev/device ]; then
            echo -n "${dev}: "
            check_disk_stat ${dev}
            operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        fi
    done
    # [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# hardware type
function check_hardware_type() {
    uname -i 2>/dev/null || uname -m 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# hostname
function check_hostname() {
    hostname -s 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# ifconfig
function check_ip_addresses() {
    addresses="$(ifconfig 2>/dev/null |awk '/inet adr/ {print $2}' |sed 's/adr:\([0-9.]\)/\1/')"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    echo ${addresses}
    return ${error:-0}
}

# ifconfig eth0
function check_ip_address() {
    for operand in $@ ${OPERAND}; do
        case "${operand}" in
            *.*.*.*)
                ifconfig 2>/dev/null |awk '/inet adr/ {print $2}' |sed 's/adr:\([0-9.]\)/\1/' |grep "${operand}" >/dev/null
                operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
                [ ${operand_error} -ne 0 ] && echo -n ${ERROR} || echo -n ${OK}
                ;;
            *)
                addresses="$(ifconfig ${operand} 2>/dev/null |awk '/inet adr/ {print $2}' |sed 's/adr:\([0-9.]\)/\1/')"
                operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
                echo ${addresses}
                ;;
        esac
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# kernel date
function check_kernel_date() {
    kernel_date="$(uname -v 2>/dev/null |awk '{$1=$2=""; print}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    [ ${NUMERIC} ] && echo $(date -d "${kernel_date}" +%s 2>/dev/null) || echo $(date -d "${kernel_date}" +${DATE_FORMAT} 2>/dev/null)
    return ${error:-0}
}

# kernel release
function check_kernel_release() {
    uname -r 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# kernel version
function check_kernel_version() {
    uname -v 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# last boot time
function check_last_reboot() {
    last_reboot="$(last reboot 2>/dev/null |head -1 |awk '{print $5" "$6" "$7" "$8}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    [ ${NUMERIC} ] && echo $(date -d "${last_reboot}" +%s 2>/dev/null) || echo $(date -d "${last_reboot}" +${DATE_FORMAT} 2>/dev/null)
    return ${error:-0}
}

# number of files, unique files, threads and sockets opened by a process
function check_open_files() {
    for operand in $@ ${OPERAND}; do
        open_files=$(for pid in $(/sbin/pidof ${operand} 2>/dev/null); do ls -l /proc/${pid}/fd 2>/dev/null |sed 1d; done |wc -l)
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        [ -n "${open_files}" ] && echo -n "${open_files} "
    done
    echo
    [ ${INFO} ] && for operand in $@ ${OPERAND}; do
        pidof ${operand} >/dev/null 2>&1 && echo && ps -eLf |awk 'BEGIN {totalfiles=0; totalufiles=0; totalthreads=0; totalsockets=0} $10 ~ /'${operand}'/ {user[$2]=$1; date[$2]=$7; thread[$2]+=1} END { for (pid in user) {files="ls -l /proc/"pid"/fd 2>/dev/null |sed 1d |wc -l"; files |getline openfiles[pid]; ufiles="ls -l /proc/"pid"/fd 2>/dev/null |sed 1d |cut -d\" \" -f 11 |grep -vE \"(socket)\" |sort -u |wc -l"; ufiles |getline uniquefiles[pid]; sockets="ls -l /proc/"pid"/fd 2>/dev/null |cut -d\" \" -f 11 |grep -E \"(socket)\" |sort -u |wc -l"; sockets |getline opensockets[pid]; totalopenfiles+=openfiles[pid]; totaluniquefiles+=uniquefiles[pid]; totalthreads+=thread[pid]; totalopensockets+=opensockets[pid]; print "user: "user[pid]", pid: "pid", date: "date[pid]", fichiers: "openfiles[pid]", uniques: "uniquefiles[pid]", threads: "thread[pid]", sockets: "opensockets[pid]}; print "TOTAL '${operand}' ... fichiers: "totalopenfiles", uniques: "totaluniquefiles", threads: "totalthreads", sockets: "totalopensockets}' 
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
    done
    [ ${error:-0} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# package is installed
function check_package() {
    for operand in $@ ${OPERAND}; do
        rpm -q ${operand} >/dev/null 2>&1 \
        || dpkg -s ${operand} >/dev/null 2>&1
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        [ ${operand_error} -ne 0 ] && echo -n ${ERROR} || echo -n ${OK}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERROR_NOT_FOUND_PACKAGE}
    return ${error:-0}
}

# package install date
function check_package_date() {
    for operand in $@ ${OPERAND}; do
        package_date="$(rpm -q ${operand} --queryformat '%{installtime}' 2>/dev/null)" \
        || package_date="$(date -r /var/lib/dpkg/info/${operand}.list +%s 2>/dev/null)"
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        [ ${NUMERIC} ] && echo -n ${package_date} || echo -n $(date -d "@${package_date}" +${DATE_FORMAT} 2>/dev/null)
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERROR_NOT_FOUND_PACKAGE}
    return ${error:-0}
}

# package release
function check_package_release() {
    for operand in $@ ${OPERAND}; do
        package_release="$(rpm -q ${operand} --queryformat '%{release}' 2>/dev/null)" \
        || package_release="$(dpkg-query -W -f '${Revision}' ${operand} 2>/dev/null)"
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        echo -n ${package_release}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERROR_NOT_FOUND_PACKAGE}
    return ${error:-0}
}

# package version
function check_package_version() {
    for operand in $@ ${OPERAND}; do
        package_version="$(rpm -q ${operand} --queryformat '%{version}' 2>/dev/null)" \
        || package_version="$(dpkg-query -W -f '${Version}' ${operand} 2>/dev/null)"
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        echo -n ${package_version}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERROR_NOT_FOUND_PACKAGE}
    return ${error:-0}
}

# service is running
function check_pidof() {
    for operand in $@ ${OPERAND}; do
        # search with pidof, ps, or lsof 
        # $operand looks like : process_to_search:type_of_search:column_to_search:word_to_search
        input=($(echo $operand |awk 'BEGIN{FS=":"} {print $1" "$2" "$3" "$4}'))
        # input is an array with process, type, column and word to search
        process_to_search=${input[0]}
        type_of_search=${input[1]}
        column_to_search=${input[2]}
        word_to_search=${input[3]}
        # search_pid_command depends on type_of_search
        # default : $(pidof $process_to_search)
        # ps : $(ps ax |awk '$5 ~ /$process_to_search/ && $column_to_search ~ /$word_to_search/ {print $1}')
        # lsof : $(lsof -p $(pidof $process_to_search) |awk '/$word_to_search/ {print $9}')
        #
        # default search command is pidof
        search_pid_command="pidof ${process_to_search}"
        # if type ps
        [ "${type_of_search}" = 'ps' ] && [ -z "${column_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ {print \$1}'"
        [ "${type_of_search}" = 'ps' ] && [ -n "${column_to_search}" ] && [ -z "${word_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ && \$${column_to_search} ~ /${process_to_search}/ {print \$1}'"
        [ "${type_of_search}" = 'ps' ] && [ -n "${column_to_search}" ] && [ -n "${word_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ && \$${column_to_search} ~ /${word_to_search}/ {print \$1}'"
        # if type lsof
        [ "${type_of_search}" = 'lsof' ] && [ -n "${column_to_search}" ] && [ -n "${word_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ {print \$1}' |while read pid; do lsof -p \${pid} |awk '\$${column_to_search} ~ /${word_to_search}/ {print \$2}'; done"
        # process the command
        process_pid=$(sh -c "${search_pid_command}" 2>/dev/null)
        operand_error=$?
        # test error if output is empty 
        [ -z "${process_pid}" ] && operand_error=1
        [ -z "${process_pid}" ] && echo -n ${ERROR}
        [ -n "${process_pid}" ] && [ ! ${NUMERIC} ] && echo -n ${OK}
        [ -n "${process_pid}" ] && [ ${NUMERIC} ] && echo -n ${process_pid}
        [ ${operand_error:-0} -gt ${error:-0} ] && error=${operand_error}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERROR_NOT_FOUND_PROCESS}
    return ${error:-0}
}

# processor type
function check_processor_type() {
    uname -p 2>/dev/null 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# system install date 
function check_system_date() {
    install_date="$(rpm -q basesystem --queryformat '%{installtime}' 2>/dev/null)" \
    || install_date=$(date -d "$(LANG=en_EN ls -alt /var/lib/dpkg/info/*.list 2>/dev/null |tail -1 |awk '{print $6" "$7" "$8}')" +%s 2>/dev/null) \
    || install_date=$(date -d "$(LANG=en_EN ls -alt /var/log/installer/ 2>/dev/null |tail -1 |awk '{print $6" "$7" "$8}')" +%s 2>/dev/null) \
    || install_date=$(date -d "$(LANG=en_EN ls -alt / 2>/dev/null |tail -1 |awk '{print $6" "$7" "$8}')" +%s 2>/dev/null)
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    [ ${NUMERIC} ] && echo ${install_date} || echo $(date -d @${install_date} +${DATE_FORMAT} 2>/dev/null)
    return ${error:-0}
}

# number of open files
function check_system_open_files() {
    cat /proc/sys/fs/file-nr 2>/dev/null |awk '{print $1}'
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# system release
function check_system_release() {
    lsb_release -d 2>/dev/null |sed 's/^Description:[[:blank:]]*//' \
    || cat /etc/redhat-release 2>/dev/null \
    || cat /etc/debian_version 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# tcp connection over ssl
function check_ssl() {
    SSL=1 check_tcp $@
}

# tcp connection over tls
function check_starttls() {
    STARTTLS=1 check_tls $@
}

# tcp connection over tls
function check_starttls_ftp() {
    PROT=ftp check_starttls $@
}

# tcp connection over tls
function check_starttls_imap() {
    PROT=imap check_starttls $@
}

# tcp connection over tls
function check_starttls_pop3() {
    PROT=pop3 check_starttls $@
}

# tcp connection over tls
function check_starttls_smtp() {
    PROT=smtp check_starttls $@
}

# tcp connection over tls
function check_starttls_xmpp() {
    PROT=xmpp check_starttls $@
}

# tcp connection over tls
function check_tls() {
    TLS=1 check_ssl $@
}

# tcp connection
function check_tcp() {
    for operand in $@ ${OPERAND}; do
        case "${operand}" in
            *:*)
                host=${operand%%:*}
                port=${operand##*:}
                ;;
            *)
                port=${operand}
                ;;
        esac
        which nc >/dev/null 2>&1 && check_tcp_command="nc -w 1 ${host:-127.0.0.1} ${port} </dev/null"
        which timeout >/dev/null 2>&1 && TIMEOUT="timeout 1"
        [ ${STARTTLS} ] && starttls="-starttls ${PROT:-smtp}"
        [ ${TLS} ] && tls="-tls1"
        [ ${SSL} ] && which openssl >/dev/null 2>&1 && check_tcp_command="${TIMEOUT:-} openssl s_client -connect ${host:-127.0.0.1}:${port} ${tls:-} ${starttls:-} </dev/null 2>&1 |grep CERTIFICATE"
        [ -z "${check_tcp_command}" ] && error=${ERROR_NOT_FOUND_ALL_BINARIES} && echo -n ${ERROR} && continue
        sh -c "${check_tcp_command}" >/dev/null 2>&1
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${ERROR_CONNECTION_FAILED_TCP}
        [ ${operand_error} -ne 0 ] && echo -n ${ERROR} || echo -n ${OK}
        echo -n " "
    done
    echo
    return ${error:-0}
}

# https connection
function check_https_tls() {
    TLS=1 check_https $@
}

# https connection
function check_https() {
    SSL=1 check_http $@
}

# http connection
function check_http() {
    for operand in ${@:-127.0.0.1} ${OPERAND}; do
        hostname=""; addr=""; host=""; port=""; url=""; pattern=""
        # extract hostname, port, url, and pattern from the operand
        # hostname can be an expression like user:pass@host#addr
        case "${operand}" in
            # hostname:port/url~pattern
            *:*/*~*)
                # ":" can be used twice, for user:pass or hostname:port
                case "${operand}" in
                    # user:pass@host:port/url~pattern == hostname:port/url~pattern
                    *@*:*)
                        hostname=${operand%:*}
                        port_url_pattern=${operand##*:}
                        port=${port_url_pattern%%/*}
                        url_pattern=${port_url_pattern#*/}
                        url="/${url_pattern%%~*}"
                        pattern=${operand##*~}
                        ;;
                    # user:pass@host/url~pattern == hostname/url~pattern
                    *:*@*)
                        hostname=${operand%/*}
                        url_pattern=${operand#*/}
                        url="/${url_pattern%%~*}"
                        pattern=${operand##*~}
                        [ ${SSL} ] && port=443 || port=80
                        ;;
                esac
                ;;
            # hostname:port/url
            *:*/*)
                # ":" can be used twice, for user:pass or hostname:port
                case "${operand}" in
                    # user:pass@host:port/url == hostname:port/url
                    *@*:*)
                        hostname=${operand%:*}
                        port_url=${operand##*:}
                        port=${port_url%%/*}
                        url="/${port_url#*/}"
                        ;;
                    # user:pass@host/url == hostname/url
                    *:*@*)
                        hostname=${operand%%/*}
                        url="/${operand#*/}"
                        [ ${SSL} ] && port=443 || port=80
                        ;;
                esac
                ;;
            # hostname:port~pattern
            *:*~*)
                # ":" can be used twice, for user:pass or hostname:port
                case "${operand}" in
                    # user:pass@host:port~pattern == hostname:port~pattern
                    *@*:*)
                        hostname=${operand%:*}
                        port_pattern=${operand##*:}
                        port="${port_pattern%%~*}"
                        pattern=${port_pattern##*~}
                        ;;
                    # user:pass@host~pattern == hostname~pattern
                    *:*@*)
                        hostname=${operand%%~*}
                        pattern=${operand##*~}
                        ;;
                esac
                ;;
            # hostname/url~pattern
            */*~*)
                hostname=${operand%%/*}
                url_pattern=${operand#*/}
                url="/${url_pattern%%~*}"
                pattern=${url_pattern##*~}
                [ ${SSL} ] && port=443 || port=80
                ;;
            # hostname~pattern
            *~*)
                hostname=${operand%%~*}
                pattern=${operand##*~}
                [ ${SSL} ] && port=443 || port=80
                ;;
            # hostname/url
            */*)
                hostname=${operand%%/*}
                url="/${operand#*/}"
                [ ${SSL} ] && port=443 || port=80
                ;;
            # hostname:port
            *:*)
                # ":" can be used twice, for user:pass or hostname:port
                case "${operand}" in
                    # user:pass@host:port == hostname:port
                    *@*:*)
                        hostname=${operand%:*}
                        port=${operand##*:}
                        ;;
                    # user:pass@host == hostname
                    *:*@*)
                        hostname=${operand}
                        [ ${SSL} ] && port=443 || port=80
                        ;;
                esac
                ;;
            # hostname
            *)
                hostname=${operand}
                [ ${SSL} ] && port=443 || port=80
                ;;
        esac
        # check the hostname to get the user, pass, host, and addr
        case "${hostname}" in
            # user:pass@host#addr
            *:*@*#*)
                user=${hostname%:*}
                pass_host_addr=${hostname##*:}
                pass=${pass_host_addr%%@*}
                host_addr=${pass_host_addr#*@}
                host="${host_addr%%#*}"
                addr=${hostname##*#}
                ;;
            # user@host#addr
            *@*#*)
                user=${hostname%%@*}
                host_addr=${hostname#*@}
                host="${host_addr%%#*}"
                addr=${host_addr##*#}
                ;;
            # user:pass@host
            *:*@*)
                user=${hostname%:*}
                pass_host=${hostname##*:}
                pass=${pass_host%%@*}
                host="${pass_host#*@}"
                ;;
            # user@host
            *@*)
                user=${hostname%%@*}
                host=${hostname#*@}
                ;;
            # host#addr
            *#*)
                host=${hostname%%#*}
                addr=${hostname#*#}
                ;;
            # host
            *)
                host=${hostname}
                ;;
        esac
        [ -z "${addr}" ] && addr="${host}"

# echo "operand: "${operand}
# echo "hostname: "$hostname
# echo "user: "$user
# echo "pass: "$pass
# echo "host: "$host
# echo "addr: "$addr
# echo "port: "$port
# echo "url: "$url
# echo "pattern: "$pattern

        which nc >/dev/null 2>&1 && check_http_command="nc -w 1 ${addr:-127.0.0.1} ${port:-80}"
        which timeout >/dev/null 2>&1 && TIMEOUT="timeout 1"
        [ ${TLS} ] && tls="-tls1"
        [ ${SSL} ] && which openssl >/dev/null 2>&1 && check_http_command="${TIMEOUT:-} openssl s_client -quiet -connect ${addr:-127.0.0.1}:${port:-443} ${tls:-}"
        [ -z "${check_http_command}" ] && error=${ERROR_NOT_FOUND_ALL_BINARIES} && echo -n ${ERROR} && continue
        check_http_command="echo -e 'GET ${url:-/} HTTP/1.0\nHost: ${host:-localhost}\nUser-Agent: $(basename $0) v${RELEASE}\n\n' |${check_http_command}"
        sh -c "${check_http_command}" 2>/dev/null |while read line; do
            [ ${cpt:-0} -eq 0 ] && check_http_return=(${line}) && \
            check_http_return_protocol=${check_http_return[0]} && check_http_return_code=${check_http_return[1]} && check_http_return_message=${check_http_return[2]}
            case "${line}" in
                *${pattern:-}*)
                    for valid_code in ${VALID_RESPONSE_CODE_HTTP}; do
                        # we are in a subshell, so we have to return a specific code (42) to tell that we found the pattern
                        [ ${check_http_return_code:-0} -eq ${valid_code} ] && return 42
                    done
                    return ${ERROR_RESPONSE_CODE_HTTP}
                    ;;
            esac
            # echo line $cpt: $line
            cpt=$((${cpt} + 1))
        done
        # if subshell returned 42, then pattern has been found
        operand_error=$? && [ ${operand_error} -ne 42 ] && error=${operand_error} && echo -n ${ERROR} || echo -n ${OK}
        # if subshell returned 0, then pattern has not been found
        [ ${operand_error} -eq 0 ] && error=${ERROR_NOT_FOUND_HTTP_PATTERN}
        # if subshell returned 1, then tcp connection has failed
        [ ${operand_error} -eq 1 ] && error=${ERROR_CONNECTION_FAILED_TCP}
        echo -n " "
    done
    echo
    return ${error:-0}
}

# check version
function check_version() {
    echo ${RELEASE}
    error=$? && [ ${error} -ne 0 ] && error=${ERROR_UNDEFINED}
    return ${error:-0}
}

# load functions override
[ -r "$0_function" ] && source "$0_function"

# # -a flag
 #
# list all tests
[ ${LIST} ] && [ ${ALL} ] && \
    compgen -A function check_ |sed 's/^check_//' && \
    exit 0
# select all tests
[ -n "${ALL}" ] && TESTS="${TESTS} $(compgen -A function check_| sed 's/^check_//')"

# #
 #
# lock to prevent other process running
LOCK="/tmp/.lock-${0##*/}"
set -o noclobber
(echo "$$" > $LOCK) 2>/dev/null && trap "rm ${LOCK}; exit" INT TERM || error=${ERROR_LOCKED}
set +o noclobber
[ ${error:-0} -ne 0 ] && exit=${error} && echo "ERROR : $(basename $0) is LOCKED on ${hostname}. Please remove ${LOCK}" && exit ${exit}

# #
 #
# remove duplicate tests
tests="$(echo $TESTS |xargs -n1 |awk '!t[$0]++' |xargs)"
# lauch valid tests
for test in ${tests}; do
    # check if function is defined, or search for a defined function and an operand
    # type check_${test} >/dev/null 2>&1 || type check_${test%_*} >/dev/null 2>&1
    check_function="check_${test}"; check_operand=""
    while [ "${check_function}" != 'check' ]; do
        type ${check_function} >/dev/null 2>&1 && break
        case ${check_function} in
            *://*)
                [ -z "${check_operand}" ] && check_operand="${check_function##*://}" || check_operand="${check_function##*://}_${check_operand}"
                check_function="${check_function%://*}"
            ;;
            *)
                [ -z "${check_operand}" ] && check_operand="${check_function##*_}" || check_operand="${check_function##*_}_${check_operand}"
                check_function="${check_function%_*}"
            ;;
        esac
    done
    # test does not exist
    [ "${check_function}" = 'check' ] && {
        [ ${QUIET} ] || echo "WARNING: ${test} is not a valid test" >&2
        [ ${exit:-0} -gt ${ERROR_NOT_FOUND_TEST} ] || exit=${ERROR_NOT_FOUND_TEST}
        continue
    }
    # echo test
    [ ${QUIET} ] || echo -n "Testing ${test} ... "
    # launch test
    error=0
    # launch check_the_function_name, or check_the_function name, or check_the function_name
    ${check_function} "${check_operand//,/ }"
    error=$? && [ ${error} -ne 0 ] && errors="${errors} ${test}"
    # exit code will be the highest error code returned by all the tests
    [ ${error} -gt ${exit} ] && exit=${error}
done

# if -s flag, show tests in error
[ ${SUMMARY} ] && exec 1>&3 3>&-
[ ${SUMMARY} ] && [ ! ${QUIET} ] && echo -n "Tests in error ... "
[ ${SUMMARY} ] && for error in ${errors}; do echo -n "${error} "; done
[ ${SUMMARY} ] && [ ! ${QUIET} ] && echo

# unlock
rm -f "${LOCK}" 2>/dev/null && trap - INT TERM

# exit
exit ${exit}
