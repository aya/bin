#!/bin/bash
#
# # test script for linux server
 #
# Author: Yann Autissier <yann.autissier@anotherservice.com>
#
# History:
# 20130826 AYA : wget profiles and functions from remote files
# 20130824 AYA : pass arguments to tests, call restart on failed tests, factorize functions
# 20130823 AYA : get profile from hostname, summary output for supervision, debian support
# 20130821 AYA : user account list
# 20130819 AYA : package information
# 20130816 AYA : define group of tests in profiles
# 20130814 AYA : check open files for DB2, numeric output for supervision
# 20130731 AYA : first version for redhat, check few services
#
RELEASE="0.6.2"

# #
 #
# error codes
exit=0
ERR_BINNOTFOUND=1
ERR_TESTNOTFOUND=2
ERR_PROCESSNOTFOUND=4
ERR_PACKAGENOTFOUND=8
ERR_SERVICENOTFOUND=16
ERR_UPGRADEFAILED=32
ERR_UNDEFINED=64
ERR_LOCKED=128

# error code goes through pipes
set -o pipefail

# #
 #
# binaries
AWK=$(which awk 2>/dev/null)
CAT=$(which cat 2>/dev/null)
CUT=$(which cut 2>/dev/null)
DPKG=$(which dpkg 2>/dev/null)
HOSTNAME=$(which hostname 2>/dev/null)
GREP=$(which grep 2>/dev/null)
LAST=$(which last 2>/dev/null)
LASTLOG=$(which lastlog 2>/dev/null)
LSOF=$(which lsof 2>/dev/null)
PIDOF=$(which pidof 2>/dev/null)
PS=$(which ps 2>/dev/null)
RPM=$(which rpm 2>/dev/null)

# #
 #
# default profile
DEFAULT=""
# this script (remote upgrade)
REMOTE_SCRIPT="http://10.100.11.80/tools/check"
# remote profile override
REMOTE_PROFILE="http://10.100.11.80/tools/check_profile"
# remote function override
REMOTE_FUNCTION="http://10.100.11.80/tools/check_function"

# date format
DATE_FORMAT="%d/%m/%Y"

# #
 #
# help
function usage() {
echo "Usage: $0 [options] test [test [...]]
Test de serveurs linux - v${RELEASE}

options:
        -a, --all               lance tous les tests
        -d, --debug             active la mode de deboggage
        -h, --help              affiche ce message
        -i, --info              affiche des informations detaillees pour certains tests
        -l, --list              affiche les jeux de tests de tous les profils
        -la, --list --all       affiche tous les jeux de tests disponibles
        -n, --numeric           retourne uniquement des valeurs numeriques
        -o, --operand=<operand> passe un argument <operand> a tous les tests
        -p, --profile=<profil>  utilise le jeu de test pour le <profil>
        -q, --quiet             active le mode silencieux
        -r, --restart           utilise la commande restart quand un test retourne une erreur
        -s, --summary           affiche la liste des tests en erreur
        -u, --update            force la mise a jour des fichiers de profiles et de fonctions
        -v, --version           affiche la version"
}

# #
 #
# check options
while getopts "adhilno:p:qrsuv-:" Option; do
    case "$Option" in
        -)
            case $OPTARG in
                all)
                    ALL=1
                    ;;
                debug)
                    DEBUG=1
                    ;;
                help)
                    HELP=1
                    ;;
                info)
                    INFO=1
                    ;;
                list)
                    LIST=1
                    ;;
                numeric)
                    NUMERIC=1
                    ;;
                operand)
                    OPERAND="${OPERAND} ${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                    ;;
                operand=*)
                    OPERAND="${OPERAND} ${OPTARG#*=}"
                    ;;
                profile)
                    PROFILE="${PROFILE} PROFILE_${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                    ;;
                profile=*)
                    PROFILE="${PROFILE} PROFILE_${OPTARG#*=}"
                    ;;
                quiet)
                    QUIET=1
                    ;;
                restart)
                    RESTART=1
                    ;;
                summary)
                    SUMMARY=1
                    ;;
                update)
                    UPDATE=$((${UPDATE:-0} + 1))
                    ;;
                version)
                    VERSION=1
                    ;;
            esac
            ;;
        a)
            ALL=1
            ;;
        d)
            DEBUG=1
            ;;
        h)
            HELP=1
            ;;
        i)
            INFO=1
            ;;
        l)
            LIST=1
            ;;
        n)
            NUMERIC=1
            ;;
        o)
            OPERAND="${OPERAND} ${OPTARG}"
            ;;
        p)
            PROFILE="${PROFILE} PROFILE_${OPTARG}"
            ;;
        q)
            QUIET=1
            ;;
        r)
            RESTART=1
            ;;
        s)
            SUMMARY=1
            ;;
        u)
            UPDATE=$((${UPDATE:-0} + 1))
            ;;
        v)
            VERSION=1
            ;;
        *)
            usage
            exit 0
            ;;
    esac
done
shift $(($OPTIND - 1))

# #
 #
# check binaries
[ -z "${AWK}" ] || [ -z "${CAT}" ] || [ -z "${CUT}" ] || [ -z "${HOSTNAME}" ] || [ -z "${GREP}" ] || [ -z "${LAST}" ] ||[ -z "${LASTLOG}" ] ||  [ -z "${LSOF}" ] || [ -z "${PIDOF}" ] || [ -z "${PS}" ] || [ -z "${RPM}" -a -z "${DPKG}" ] && exit=${ERR_BINNOTFOUND}
[ ${exit} -ne 0 ] && echo "ERROR: Unable to find all needed binaries" >&2 && exit $exit

# #
 #
# process options
# set debug
[ ${DEBUG} ] && set -x
# show help
[ ${HELP} ] && usage && exit 0
# show version
[ ${VERSION} ] && echo "$(basename $0) v${RELEASE}" && exit 0

# update profiles and functions from remote host
[ ${UPDATE:-0} -gt 1 ] && {
    # get profiles from remote file
    wget --proxy=off -q "${REMOTE_PROFILE}" -O "/tmp/.$(basename $0)_profile.$$" 2>/dev/null || echo "WARNING: Unable to wget ${REMOTE_PROFILE}" >&2
    # if file is not empty, overwrite local file
    [ -s "/tmp/.$(basename $0)_profile.$$" ] && mv "/tmp/.$(basename $0)_profile.$$" $0_profile && chmod +r $0_profile || error=${ERR_UPGRADEFAILED}
    # get functions from remote file
    wget --proxy=off -q "${REMOTE_FUNCTION}" -O "/tmp/.$(basename $0)_function.$$" 2>/dev/null || echo "WARNING: Unable to wget ${REMOTE_FUNCTION}" >&2
    # if file is not empty, overwrite local file
    [ -s "/tmp/.$(basename $0)_function.$$" ] && mv "/tmp/.$(basename $0)_function.$$" $0_function && chmod +r $0_function || error=${ERR_UPGRADEFAILED}
    # exit if upgrade failed
    [ ${error:-0} -ne 0 ] && exit ${error}
}

# Not documented : auto upgrade, overwrite this script !
[ ${UPDATE:-0} -gt 1 ] && {
    [ ! ${QUIET} ] && echo -n "Do you really want to upgrade this script ? [y/N] : " && read UPGRADE
    [[ ${QUIET} || ${UPGRADE} =~ ^(Y|y) ]] && {
        wget --proxy=off -q "${REMOTE_SCRIPT}" -O "/tmp/.$(basename $0).$$" 2>/dev/null || error=${ERR_UPGRADEFAILED}
        [ ${error:-0} -ne 0 ] && echo "WARNING: Unable to wget ${REMOTE_SCRIPT}" >&2 && exit ${error:-0}
        [ ! ${QUIET} ] && NEW_RELEASE=$(awk 'BEGIN {FS="="} $1 == "RELEASE" {print $2}' /tmp/.$(basename $0).$$ |sed 's/"//g') && echo -n "Downloaded version : ${NEW_RELEASE}, Current version : ${RELEASE}, continue ? [y/N] : " && read UPGRADE_OK
        [[ ${QUIET} || ${UPGRADE_OK} =~ ^(Y|y) ]] && {
            [ -s "/tmp/.$(basename $0).$$" ] && mv "/tmp/.$(basename $0).$$" $0 && chmod +x $0 || error=${ERR_UPGRADEFAILED}
            [ ${error:-0} -ne 0 ] && {
                echo "ERROR: Upgrade failed !" >&2
            } || {
                [ ! ${QUIET} ] && echo "INFO: Upgrade Successful"
            }
        }
    }
# exit
exit ${error:-0}
}

# load profiles override
[ -r "$0_profile" ] && source "$0_profile"
# functions override is loaded after local functions definition

# list profiles
[ ${LIST} ] && [ ! ${ALL} ] && \
    echo "Listing profiles :" && \
    echo DEFAULT: ${DEFAULT} && \
    for profile in $(compgen -v PROFILE_); do
       echo ${profile/PROFILE_/}: ${!profile}
    done && exit 0
# output numeric values for nagios
[ ${NUMERIC} ] && OK=1 || OK="OK"
[ ${NUMERIC} ] && ERROR=0 || ERROR="ERROR"
# -s flag display only summary
[ ${SUMMARY} ] && exec 3>&1 >/dev/null

# #
 #
# get list of tests from argv
TESTS="$@"
# if no input, check hostname to define current profile
hostname="$(hostname -s)"
# ^^ need bash v4
# HOSTNAME=${hostname^^}
HOSTNAME=$(hostname -s |tr '[a-z]' '[A-Z]')
[ -z "${TESTS}" ] && for profile in $(compgen -v PROFILE_); do
    [[ ${HOSTNAME} =~ ${profile/PROFILE_/} ]] && PROFILE="${PROFILE} ${profile}"
    [[ ${HOSTNAME/-/} =~ ${profile/PROFILE_/} ]] && PROFILE="${PROFILE} ${profile}"
done
# if no input, use DEFAULT tests
[ -n "${TESTS}" ] || TESTS="${DEFAULT}"
# then add tests from profiles
for profile in ${PROFILE}; do
    # check if profile is defined
    [ -n "${!profile}" ] && TESTS="${TESTS} ${!profile}" || [ ${QUIET} ] || echo "WARNING: ${profile} is not a valid profile" >&2
done

# #
 #
# functions are defined from here

# active accounts
function check_account_active() {
    account_active="$(grep -vE '.*:\*|:\!' /etc/shadow 2>/dev/null |awk -F: '{print $1}')"
    [ ${NUMERIC} ] && account_active="$(for account_active_user in ${account_active}; do id -u ${account_active_user}; done)"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_active}
    return ${error:-0}
}

# account lastlog
function check_account_lastlog() {
    [ ${QUIET} ] || echo
    LANG=en_EN lastlog 2>/dev/null |awk '$2 ~ /(pts|tty)/' |\
        while read account_lastlog_user account_lastlog_pts account_lastlog_address account_lastlog_date; do 
            [ -z "${account_lastlog_user}" ] && continue
            [ ${NUMERIC} ] && echo -n "$(id -u ${account_lastlog_user}): " || echo -n "${account_lastlog_user}: "
            [ ${NUMERIC} ] && echo $(date -d "${account_lastlog_date}" +%s 2>/dev/null) || echo $(date -d "${account_lastlog_date}" +${DATE_FORMAT} 2>/dev/null)
            account_lastlog_user=""; account_lastlog_pts=""; account_lastlog_address=""; account_lastlog_date=""
        done
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# account last logged in users
function check_account_last_login() {
    [ ${QUIET} ] || echo
    LANG=en_EN last 2>/dev/null |awk '$2 ~ /(pts|tty)/' |\
        while read account_last_login_user account_last_login_pts account_last_login_address account_last_login_date; do 
            [ -z "${account_last_login_user}" ] || [ "${account_last_login_user}" = "reboot" ] && continue
            account_last_login_date="$(echo ${account_last_login_date} |awk '{print $1" "$2" "$3" "$4}')"
            [ ${NUMERIC} ] && echo -n "$(id -u ${account_last_login_user}): " || echo -n "${account_last_login_user}: "
            [ ${NUMERIC} ] && echo $(date -d "${account_last_login_date}" +%s 2>/dev/null) || echo $(date -d "${account_last_login_date}" +${DATE_FORMAT} 2>/dev/null)
            account_last_login_user=""; account_last_login_pts=""; account_last_login_address=""; account_last_login_date=""
        done
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# account list
function check_account_list() {
    account_list="$(cat /etc/passwd 2>/dev/null |grep -vE '^(#|$)' |cut -d: -f1)"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_list}
    [ ${NUMERIC} ] || [ ${QUIET} ] || cat /etc/passwd 2>/dev/null |grep -vE '^(#|$)' |\
        while IFS=":" read account_list_user account_list_password account_list_uid account_list_gid account_list_description account_list_homedir account_list_loginshell; do
            [ -z "${account_list_user}" ] && continue
            # check login shell
            [[ "${account_list_loginshell}" =~ /(usr/)?s?bin/(nologin|false) ]] && account_list_login_status='nologin' || account_list_login_status='enabled'
            # check password
            account_list_shadow=$(cat /etc/shadow 2>/dev/null |grep -vE '^(#|$)' |awk 'BEGIN {FS=":"} $1 == "'${account_list_user}'" {print $2}')
            [ "${account_list_password}" = 'x' ] && account_password="${account_list_shadow}" || account_password="${account_list_password}"
            # check password algorithm
            echo "${account_password}" |grep -E '^\$(1|md5)\$' >/dev/null 2>&1 && account_list_password_type='md5'
            echo "${account_password}" |grep -E '^\$(2|2a|2x|2y)\$' >/dev/null 2>&1 && account_list_password_type='blowfish'
            echo "${account_password}" |grep -E '^\$(3)\$' >/dev/null 2>&1 && account_list_password_type='nt-hash'
            echo "${account_password}" |grep -E '^\$(4)\$' >/dev/null 2>&1 && account_list_password_type='sha1'
            echo "${account_password}" |grep -E '^\$(5)\$' >/dev/null 2>&1 && account_list_password_type='sha2-256'
            echo "${account_password}" |grep -E '^\$(6)\$' >/dev/null 2>&1 && account_list_password_type='sha2-512'
            # check password status
            [[ "${account_password}" = '*' || "${account_password}" = '!' ]] && account_list_password_type='locked'
            [[ "${account_password}" = '!!' ]] && account_list_password_type='expired'
            [ "${account_password}" = '' ] && account_list_password_status='empty'
            # check last login
            account_list_last_login="$(LANG=en_EN lastlog -u ${account_list_user} |sed 1d |awk '$2 ~ /pts/ {$1=$2=$3=""; print}; $2 ~ /tty/ {$1=$2=""; print}')"
            [ -n "${account_list_last_login}" ] && account_list_last_login=$(date -d "${account_list_last_login}" +${DATE_FORMAT} 2>/dev/null) || account_list_last_login="never"
            # check if account is in use
            ls /var/spool/cron 2>/dev/null |grep ${account_list_user} >/dev/null && account_list_service="crontab" 
            ls /var/spool/cron/* 2>/dev/null |grep ${account_list_user} >/dev/null && account_list_service="crontab" 
            ps aux 2>/dev/null |awk '$7 == "?" {print $1}' |grep ${account_list_user} >/dev/null && account_list_service="${account_list_service} process"
            [ -n "${account_list_service}" ] && account_list_service="$(echo ${account_list_service})" || account_list_service="none"
            # print results and accounts without password in RED
            [ "${account_list_login_status}" = "enabled" ] && [ "${account_list_password_type}" = "empty" ] && echo -ne "\e[01;31m"
            echo -n "user: ${account_list_user}, "
            echo -n "uid: ${account_list_uid}, "
            echo -n "gid: ${account_list_gid}, "
            echo -n "shell: ${account_list_loginshell}, "
            # echo -n "description: \"${account_list_description//\"/}\", "
            echo -n "status: ${account_list_login_status}, "
            echo -n "password: ${account_list_password_type}, "
            echo -n "last_login: ${account_list_last_login}, "
            echo -n "service: ${account_list_service}"
            # end of line for:  print results and accounts without password in RED
            [ "${account_list_login_status}" = "enabled" ] && [ "${account_list_password_type}" = "empty" ] && echo -e "\e[0m" || echo
            account_list_user=""; account_list_password=""; account_list_uid=""; account_list_gid=""; account_list_description=""; account_list_homedir=""; account_list_loginshell=""
            account_list_login_status=""; account_list_password_type="unknown"; account_list_shadow=""; account_list_last_login=""; account_list_service=""
        done
    return ${error:-0}
}

# account logged in
function check_account_logged_in() {
    account_logged_in="$(ps aux |awk '$7 ~ /pts|tty/ {print $1}' 2>/dev/null |sort -u)"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_logged_in}
    return ${error:-0}
}

# account with crontab
function check_account_with_crontab() {
    [ ${NUMERIC} ] && account_with_crontab="$(ls -ln /var/spool/cron /var/spool/cron/* 2>/dev/null |awk '$1 ~ /^-/ {print $3}')" || account_with_crontab="$(ls -l /var/spool/cron /var/spool/cron/* 2>/dev/null |awk '$1 ~ /^-/ {print $3}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_with_crontab}
    [ ${INFO} ] && for account_with_crontab_user in ${account_with_crontab}; do 
        cat /var/spool/cron/${account_with_crontab_user} /var/spool/cron/*/${account_with_crontab_user} 2>/dev/null |awk '$0 !~ /^(#|$)/ {print "'${account_with_crontab_user}': "$0}'
    done
    return ${error:-0}
}

# account with privileges
function check_account_with_privilege() {
    account_with_privilege="$(echo $(cat /etc/passwd 2>/dev/null |awk 'BEGIN {FS=":"} $3 == "0" {print $1}') $(check_account_with_sudo) |xargs -n1 |awk '!t[$0]++' |xargs)"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_with_privilege}
    [ ${INFO} ] && for account_with_privilege_user in ${account_with_privilege}; do 
        echo ${account_with_privilege_user}
    done
    return ${error:-0}
}

# account with process
function check_account_with_process() {
    [ ${NUMERIC} ] && account_process="$(ps aunx 2>/dev/null |awk '$7 == "?" {print $1}' |sort -u)" || account_process="$(ps aux 2>/dev/null |awk '$7 == "?" {print $1}' |sort -u)"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_process}
    return ${error:-0}
}

# account with sudo privileges
function check_account_with_sudo() {
    # user or group with sudo (root    ALL=(ALL)       ALL)
    account_or_group_with_sudo="$(cat /etc/sudoers /etc/sudoers.d/* 2>/dev/null |awk '$0 !~ /^(#|$)/ && $2 ~ /=/ && $3 ~ /ALL/ {print $1}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    for account_or_group in ${account_or_group_with_sudo}; do 
        # group begins with %
        [[ ${account_or_group} =~ ^% ]] && account_with_sudo="${account_with_sudo} $(getent group ${account_or_group/\%/} |awk 'BEGIN {FS=":"} {print $4}' |sed 's/,/ /')" || account_with_sudo="${account_with_sudo} ${account_or_group}"
    done
    echo ${account_with_sudo} |xargs -n1 |awk '!t[$0]++' |xargs
    return ${error:-0}
}

# active accounts
function check_account_without_password() {
    account_without_password="$(cat /etc/passwd /etc/shadow 2>/dev/null |grep -vE '^(#|$)' |awk 'BEGIN {FS=":"} $2 == "" {print $1}' |sort -u)"
    [ ${NUMERIC} ] && account_without_password="$(for account_without_password_user in ${account_without_password}; do id -u ${account_without_password_user}; done)"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${account_without_password}
    return ${error:-0}
}

# hardware type
function check_hardware_type() {
    uname -i 2>/dev/null || uname -m 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# hostname
function check_hostname() {
    hostname -s 2>&1
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# ifconfig
function check_ip_addresses() {
    addresses="$(ifconfig 2>/dev/null |awk '/inet adr/ {print $2}' |sed 's/adr:\([0-9.]\)/\1/')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${addresses}
    return ${error:-0}
}

# ifconfig eth0
function check_ip_address() {
    check_ip_address_eth0
}

# ifconfig eth0
function check_ip_address_eth0() {
    addresses="$(ifconfig eth0 2>/dev/null |awk '/inet adr/ {print $2}' |sed 's/adr:\([0-9.]\)/\1/')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${addresses}
    return ${error:-0}
}

# ifconfig wlan0
function check_ip_address_wlan0() {
    addresses="$(ifconfig wlan0 2>/dev/null |awk '/inet adr/ {print $2}' |sed 's/adr:\([0-9.]\)/\1/')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    echo ${addresses}
    return ${error:-0}
}

# kernel date
function check_kernel_date() {
    kernel_date="$(uname -v 2>/dev/null |awk '{$1=$2=""; print}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    [ ${NUMERIC} ] && echo $(date -d "${kernel_date}" +%s 2>/dev/null) || echo $(date -d "${kernel_date}" +${DATE_FORMAT} 2>/dev/null)
    return ${error:-0}
}

# kernel release
function check_kernel_release() {
    uname -r 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# kernel version
function check_kernel_version() {
    uname -v 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# last boot time
function check_last_reboot() {
    last_reboot="$(last reboot |head -1 |awk '{print $5" "$6" "$7" "$8}')"
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    [ ${NUMERIC} ] && echo $(date -d "${last_reboot}" +%s 2>/dev/null) || echo $(date -d "${last_reboot}" +${DATE_FORMAT} 2>/dev/null)
    return ${error:-0}
}

# number of files, unique files, threads and sockets opened by a process
function check_openfiles() {
    for operand in $1 ${OPERAND}; do
        open_files=$(for pid in $(/sbin/pidof ${operand} 2>/dev/null); do ls -l /proc/${pid}/fd 2>/dev/null |sed 1d; done |wc -l)
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        [ -n "${open_files}" ] && echo -n "${open_files} "
    done
    echo
    [ ${INFO} ] && for operand in $1 ${OPERAND}; do
        pidof ${operand} >/dev/null 2>&1 && echo && ps -eLf |awk 'BEGIN {totalfiles=0; totalufiles=0; totalthreads=0; totalsockets=0} $10 ~ /'${operand}'/ {user[$2]=$1; date[$2]=$7; thread[$2]+=1} END { for (pid in user) {files="ls -l /proc/"pid"/fd 2>/dev/null |sed 1d |wc -l"; files |getline openfiles[pid]; ufiles="ls -l /proc/"pid"/fd 2>/dev/null |sed 1d |cut -d\" \" -f 11 |grep -vE \"(socket)\" |sort -u |wc -l"; ufiles |getline uniquefiles[pid]; sockets="ls -l /proc/"pid"/fd 2>/dev/null |cut -d\" \" -f 11 |grep -E \"(socket)\" |sort -u |wc -l"; sockets |getline opensockets[pid]; totalopenfiles+=openfiles[pid]; totaluniquefiles+=uniquefiles[pid]; totalthreads+=thread[pid]; totalopensockets+=opensockets[pid]; print "user: "user[pid]", pid: "pid", date: "date[pid]", fichiers: "openfiles[pid]", uniques: "uniquefiles[pid]", threads: "thread[pid]", sockets: "opensockets[pid]}; print "TOTAL '${operand}' ... fichiers: "totalopenfiles", uniques: "totaluniquefiles", threads: "totalthreads", sockets: "totalopensockets}' 
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
    done
    [ ${error:-0} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# package is installed
function check_package() {
    for operand in $1 ${OPERAND}; do
        rpm -q ${operand} >/dev/null 2>&1 \
        || dpkg -s ${operand} >/dev/null 2>&1
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        [ ${operand_error} -ne 0 ] && echo -n ${ERROR} || echo -n ${OK}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERR_PACKAGENOTFOUND}
    return ${error:-0}
}

# package install date
function check_package_date() {
    for operand in $1 ${OPERAND}; do
        package_date="$(rpm -q ${operand} --queryformat '%{installtime}' 2>/dev/null)" \
        || package_date="$(date -r /var/lib/dpkg/info/${operand}.list +%s 2>/dev/null)"
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        [ ${NUMERIC} ] && echo -n ${package_date} || echo -n $(date -d "@${package_date}" +${DATE_FORMAT} 2>/dev/null)
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERR_PACKAGENOTFOUND}
    return ${error:-0}
}

# package release
function check_package_release() {
    for operand in $1 ${OPERAND}; do
        package_release="$(rpm -q ${operand} --queryformat '%{release}' 2>/dev/null)" \
        || package_release="$(dpkg-query -W -f '${Revision}' ${operand} 2>/dev/null)"
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        echo -n ${package_release}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERR_PACKAGENOTFOUND}
    return ${error:-0}
}

# package version
function check_package_version() {
    for operand in $1 ${OPERAND}; do
        package_version="$(rpm -q ${operand} --queryformat '%{version}' 2>/dev/null)" \
        || package_version="$(dpkg-query -W -f '${Version}' ${operand} 2>/dev/null)"
        operand_error=$? && [ ${operand_error} -gt ${error:-0} ] && error=${operand_error}
        echo -n ${package_version}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERR_PACKAGENOTFOUND}
    return ${error:-0}
}

# service is running
function check_pidof() {
    for operand in $1 ${OPERAND}; do
        # search with pidof, ps, or lsof 
        # $operand looks like : process_to_search:type_of_search:column_to_search:word_to_search
        input=($(echo $operand |awk 'BEGIN{FS=":"} {print $1" "$2" "$3" "$4}'))
        # input is an array with process, type, column and word to search
        process_to_search=${input[0]}
        type_of_search=${input[1]}
        column_to_search=${input[2]}
        word_to_search=${input[3]}
        # search_pid_command depends on type_of_search
        # default : $(pidof $process_to_search)
        # ps : $(ps ax |awk '$5 ~ /$process_to_search/ && $column_to_search ~ /$word_to_search/ {print $1}')
        # lsof : $(lsof -p $(pidof $process_to_search) |awk '/$word_to_search/ {print $9}')
        #
        # default search command is pidof
        search_pid_command="pidof ${process_to_search}"
        # if type ps
        [ "${type_of_search}" = 'ps' ] && [ -z "${column_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ {print \$1}'"
        [ "${type_of_search}" = 'ps' ] && [ -n "${column_to_search}" ] && [ -z "${word_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ && \$${column_to_search} ~ /${process_to_search}/ {print \$1}'"
        [ "${type_of_search}" = 'ps' ] && [ -n "${column_to_search}" ] && [ -n "${word_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ && \$${column_to_search} ~ /${word_to_search}/ {print \$1}'"
        # if type lsof
        [ "${type_of_search}" = 'lsof' ] && [ -n "${column_to_search}" ] && [ -n "${word_to_search}" ] && search_pid_command="ps ax |awk '\$5 ~ /${process_to_search}/ {print \$1}' |while read pid; do lsof -p \${pid} |awk '\$${column_to_search} ~ /${word_to_search}/ {print \$2}'; done"
        # process the command
        process_pid=$(sh -c "${search_pid_command}" 2>/dev/null)
        operand_error=$?
        # test error if output is empty 
        [ -z "${process_pid}" ] && operand_error=1
        [ -z "${process_pid}" ] && echo -n ${ERROR}
        [ -n "${process_pid}" ] && [ ! ${NUMERIC} ] && echo -n ${OK}
        [ -n "${process_pid}" ] && [ ${NUMERIC} ] && echo -n ${process_pid}
        [ ${operand_error:-0} -gt ${error:-0} ] && error=${operand_error}
        echo -n " "
    done
    echo
    [ ${error:-0} -ne 0 ] && error=${ERR_PROCESSNOTFOUND}
    return ${error:-0}
}

# processor type
function check_processor_type() {
    uname -p 2>/dev/null 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# system install date 
function check_system_date() {
    install_date="$(rpm -q basesystem --queryformat '%{installtime}' 2>/dev/null)" \
    || install_date=$(date -d "$(LANG=en_EN ls -alt /var/lib/dpkg/info/*.list 2>/dev/null |tail -1 |awk '{print $6" "$7" "$8}')" +%s 2>/dev/null) \
    || install_date=$(date -d "$(LANG=en_EN ls -alt /var/log/installer/ 2>/dev/null |tail -1 |awk '{print $6" "$7" "$8}')" +%s 2>/dev/null) \
    || install_date=$(date -d "$(LANG=en_EN ls -alt / 2>/dev/null |tail -1 |awk '{print $6" "$7" "$8}')" +%s 2>/dev/null)
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    [ ${NUMERIC} ] && echo ${install_date} || echo $(date -d @${install_date} +${DATE_FORMAT} 2>/dev/null)
    return ${error:-0}
}

# number of open files
function check_system_openfiles() {
    cat /proc/sys/fs/file-nr 2>/dev/null |awk '{print $1}'
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# system release
function check_system_release() {
    lsb_release -d 2>/dev/null |sed 's/^Description:[[:blank:]]*//' \
    || cat /etc/redhat-release 2>/dev/null \
    || cat /etc/debian_version 2>/dev/null
    error=$? && [ ${error} -ne 0 ] && error=${ERR_UNDEFINED}
    return ${error:-0}
}

# load functions override
[ -r "$(dirname $0)/check_function" ] && source "$(dirname $0)/check_function"

# # -a flag
 #
# list all tests
[ ${LIST} ] && [ ${ALL} ] && \
    echo "Listing tests :" && \
    compgen -A function check_ |sed 's/^check_//' && \
    exit 0
# select all tests
[ -n "${ALL}" ] && TESTS="${TESTS} $(compgen -A function check_| sed 's/^check_//')"

# # clean the list
 #
# remove duplicate tests
list="$(echo $TESTS |xargs -n1 |awk '!t[$0]++' |xargs)"
# remove invalid tests
for test in ${list}; do
    # check if test function is defined, or belongs to a defined function
    type check_${test} >/dev/null 2>&1 \
    || type check_${test%_*} >/dev/null 2>&1
    [ $? -eq 0 ] && tests="${tests} ${test}" || [ ${QUIET} ] || echo "WARNING: ${test} is not a valid test" >&2
done

# check we have valid tests
[ -z "${tests}" ] && exit=${ERR_TESTNOTFOUND}
[ ${exit} -ne 0 ] && echo "ERROR: You must specify a valid test to run" >&2 && exit ${exit}

# lock to prevent other process running
LOCK="/tmp/.lock-${0##*/}"
set -o noclobber
(echo "$$" > $LOCK) 2>/dev/null && trap "rm ${LOCK}; exit" INT TERM || error=${ERR_LOCKED}
set +o noclobber
[ ${error:-0} -ne 0 ] && exit=${error} && echo "ERROR : check is LOCKED on ${hostname}. Please remove ${LOCK}" && exit ${exit}

# show tests list
[ ${QUIET} ] || echo "Testing services ${tests/ /} :"

# launch tests
for test in ${tests}; do
    # echo test
    [ ${QUIET} ] || echo -n "Testing ${test} ... "
    # launch test
    error=0
    # launch check_function_test, or check_function test
    type check_${test} >/dev/null 2>&1 && {
        check_${test}
        error=$?
    } || {
        check_${test%_*} ${test#*_}
        error=$?
    }
    [ ${error} -ne 0 ] && errors="${errors} ${test}"
    # exit code will be the highest error code returned by all the tests
    [ ${error} -gt ${exit} ] && exit=${error}
done

# if -s flag, show tests in error
[ ${SUMMARY} ] && exec 1>&3 3>&-
[ ${SUMMARY} ] && [ ! ${QUIET} ] && echo -n "Tests in error ... "
[ ${SUMMARY} ] && for error in ${errors}; do echo -n "${error} "; done
[ ${SUMMARY} ] && [ ! ${QUIET} ] && echo

# if -r flag, restart services in error
[ ${RESTART} ] && [ -x '/usr/local/bin/restart' ] && /usr/local/bin/restart "${errors}"

# unlock
rm -f "${LOCK}" 2>/dev/null && trap - INT TERM

# exit
exit ${exit}
